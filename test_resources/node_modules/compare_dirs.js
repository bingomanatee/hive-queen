var _ = require('underscore');
var util = require('util');
var path = require('path');
var fs = require('fs');
var _DEBUG = false;
var Gate = require('gate');
var filecompare = require('filecompare');
var assert = require('assert');

/* ************************************
 *  validating that our directory comparison notices deep directory differences
 *  and validates identical directories
 * ************************************ */

/* ******* CLOSURE ********* */

var root = path.resolve(__dirname, '../test_resources');

/* ********* EXPORTS ******** */

module.exports = function compare_dirs(a, b, cb, msg, root) {
	if (!msg) msg = '';

	function _r(a) {
		if (root) {
			return a.replace(root, '');
		} else {
			return a;
		}
	}

	if (_DEBUG) console.log("start comparing \n   %s \n   %s", _r(a), _r(b));
	var gate = Gate.create();
	var lg = gate.latch();

	gate.await(function () {
		if (_DEBUG) console.log('done comparing %s and %s', _r(a), _r(b));
		cb();
	});

	fs.readdir(a, function (err, a_contents) {
		if (err) return cb(err);
		fs.readdir(b, function (err, b_contents) {
			if (err) return cb(err);

			try {
				assert.deepEqual(a_contents, b_contents, util.format(
					'directory %s files == directory %s files', _r(a), _r(b)) + (msg || ''));
			} catch (err) {
				return cb(err);
			}

			b_contents.forEach(function (b_file) {
				var a_path = path.resolve(a, b_file);
				var b_path = path.resolve(b, b_file);

				var gate2 = Gate.create();
				var la = gate2.latch();
				var lb = gate2.latch();
				var l2g = gate.latch();

				var as, bs;
				fs.stat(b_path, function (err, stat) {
					as = stat;
					la();
				});

				fs.stat(a_path, function (err, stat) {
					bs = stat;
					lb();
				});

				gate2.await(function () {
					if (!as) return cb(new Error('cannot get stat for ' + a_path));
					if (!bs) return cb(new Error('cannot get stat for ' + b_path));

					var type_msg = util.format('%s isFile of %s (%s) == typeof %s (%s)',
						msg, _r(a_path), as.isFile() ? 'TRUE' : 'false', _r(b_path), bs.isFile() ? 'TRUE' : 'false'
					);

					if(!(as.isFile() == bs.isFile())){
						return cb(new Error(type_msg));
					}

					var dir_msg = util.format('%s isDirectory of %s (%s) == typeof %s (%s)',
						msg, _r(a_path), as.isDirectory() ? 'TRUE' : 'false', _r(b_path), bs.isDirectory() ? 'TRUE' : 'false'
					);

					if(!(as.isDirectory() == bs.isDirectory())){
						return cb(new Error(dir_msg));
					}

					var l = gate.latch();
					if (as.isDirectory() && bs.isDirectory()) {
						compare_dirs(a_path, b_path, function(err){
							l();
							cb(err);
						}, msg, root);
					} else if (as.isFile() && bs.isFile()) {
						filecompare(a_path, b_path, function (isEqual) {
							if (!isEqual){
								return cb(new Error(msg + ': ' + _r(a_path) + ' == ' + _r(b_path)))
							}
							l();
						});
					} else {
						l();
					}
					l2g();
				});
			});

			lg();
		})
	})
};